leetcode

1. two sum - check whether sum of two elemnts is the target  
for (int i = 0; i< nums.length; ++i) {
            hmap.put(nums[i],i);
        }
        for (int i = 0; i< nums.length; ++i) {
            int input = target - nums[i];
            
                 if(hmap.containsKey(input) && hmap.get(input) != i){
                return new int[] {hmap.get(input),i};
                }
             
        }
        return new int[]{};

alternative

for (int i = 0; i< nums.length; ++i) {
 if(hmap.containsKey(nums[i]) 
	 return new int[] {hmap.get(input),i};
 else
          hmap.put(target-nums[i],i);
return new int[]{};


2.  two linked lists using ListNode 

 public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode(0);
        ListNode tail = dummyHead;
        int carry = 0;
        while(l1!=null || l2!=null || carry!=0){
            int d1 = (l1!=null)? l1.val :0;
            int d2 = (l2!=null)? l2.val :0;
            int sum = d1+d2+carry;
            int d = sum%10;
            carry=sum/10;
            ListNode newn = new ListNode(d);
            tail.next = newn;
            tail=tail.next;
            l1 = (l1 != null) ? l1.next : null;
            l2 = (l2 != null) ? l2.next : null;
        }
        ListNode result = dummyHead.next;
        dummyHead.next = null;
        return result;
    

3.  lobgest substring without repeating characters

 public int lengthOfLongestSubstring(String s) {
        Map<Character , Integer> charIndexMap = new HashMap<>();
         int maxLength = 0;
         int start = 0;
         for(int i=0;i<s.length();i++)
         {
            char current = s.charAt(i);
            if(charIndexMap.containsKey(current) && charIndexMap.get(current)>=start )
            {
                start = charIndexMap.get(current)+1;              

            }
            charIndexMap.put(current , i);
            maxLength = Math.max(maxLength , i-start+1);
         }
         return maxLength;
    }
}


4. median of two sorted arrays


        int m = nums1.length;
        int n = nums2.length;
        int m1 = 0, m2 = 0, i = 0,j =0;
        for (int c = 0; c <= (m+n)/2; c++) {
            m2 = m1;
            if(i!=n && j!=m)
                if(nums1[i]>nums2[j])
                m1 = nums2[j++];
            else
                m1 = nums1[i++];
            else if (i<n)
                m1 = nums1[i++];
            else
                m1 = nums2[j++];

        }
        if((n+m)%2==1)
            return (double)m1;
        else
            return ((double)m1+(double)m2)/2.0;
    }

5. longest paliandromic string

 public String longestPalindrome(String s) {
        if (s.length() <= 1) {
            return s;
        }

        int maxLen = 1;
        String maxStr = s.substring(0, 1);

        for (int i = 0; i < s.length(); i++) {
            for (int j = i + maxLen; j <= s.length(); j++) {
                if (j - i > maxLen && isPalindrome(s.substring(i, j))) {
                    maxLen = j - i;
                    maxStr = s.substring(i, j);
                }
            }
        }

        return maxStr;
    }

    private boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;

        while (left < right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }

        return true;
    }
}

using recursion

public String longestPalindrome(String s) {
        if (s.equals(new StringBuilder(s).reverse().toString())) {
            return s;
        }

        String left = longestPalindrome(s.substring(1));
        String right = longestPalindrome(s.substring(0, s.length() - 1));

        if (left.length() > right.length()) {
            return left;
        } else {
            return right;
        }
    }


6. zigzag conversion  2 d array used for traversal.

  if (numRows == 1 || numRows >= s.length()) {
            return s;
        }

        int idx = 0, d = 1;
        List<Character>[] rows = new ArrayList[numRows];
        for (int i = 0; i < numRows; i++) {
            rows[i] = new ArrayList<>();
        }

        for (char c : s.toCharArray()) {
            rows[idx].add(c);
            if (idx == 0) {
                d = 1;
            } else if (idx == numRows - 1) {
                d = -1;
            }
            idx += d;
        }

        StringBuilder result = new StringBuilder();
        for (List<Character> row : rows) {
            for (char c : row) {
                result.append(c);
            }
        }

        return result.toString();        
    }
}

7. reverse integres (negative included)
 if (x < 0) {
            isNegative = true;
            x = -x;
        }

        int res = 0;
        while (x > 0) {
            int digit = x % 10;
            x /= 10;
            if (res > (Integer.MAX_VALUE - digit) / 10) {
                return 0;
            }
            res = (res * 10) + digit;
        }

        return isNegative ? -res : res;      


alternative 
 boolean isNegative = x < 0;
        String strX = String.valueOf(Math.abs(x));
        StringBuilder sb = new StringBuilder(strX).reverse();
        
        try {
            res = Integer.parseInt(sb.toString());
        } catch (NumberFormatException e) {
            return 0;
        }
        
        return isNegative ? -res : res;    

8. string to integer 

lass Solution {
public:
    int myAtoi(string s) 
    {
        int i=0;
        int sign=1;
        long ans=0;
        while(i<s.length() && s[i]==' ')
            i++;
        if(s[i]=='-')
        {
            sign=-1;
            i++;
        }
        else if(s[i]=='+')
            i++;
        while(i<s.length())
        {
            if(s[i]>='0' && s[i]<='9')
            {
                ans=ans*10+(s[i]-'0');
                if(ans>INT_MAX && sign==-1)
                    return INT_MIN;
                else if(ans>INT_MAX && sign==1)
                    return INT_MAX;
                i++;
            }
            else
                return ans*sign;
        }
        return (ans*sign);
    }
};


9. paliandrome

  if (x < 0) {
            return false;
        }

        long reversed = 0;
        long temp = x;

        while (temp != 0) {
            int digit = (int) (temp % 10);
            reversed = reversed * 10 + digit;
            temp /= 10;
        }

        return (reversed == x);
    }

10. Regular Expression Matching
'.' Matches any single character.​​​​
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).
Example 1:

Input: s = "aa", p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input: s = "aa", p = "a*"
Output: true
Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input: s = "ab", p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
 

class Solution {
    public boolean isMatch(String s, String p) {
        return s.matches(p);
    }


11. maximum amount of water stored by container
   int left = 0;
        int right = height.length - 1;
        int maxArea = 0;

        while (left < right) {
            int currentArea = Math.min(height[left], height[right]) * (right - left);
            maxArea = Math.max(maxArea, currentArea);

            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }

        return maxArea;


12. integer to roman 

public String intToRoman(int num) {
        int[] n = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] s = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        int i =0;
        String str = new String(); 
        while (num>0){
            if (num>=n[i]){
                str=str+s[i];
                num-=n[i];
            } else{
                i++;
            }
        }
        return str;
alternative

  String ones[] = {"","I","II","III","IV","V","VI","VII","VIII","IX"};
        String tens[] = {"","X","XX","XXX","XL","L","LX","LXX","LXXX","XC"};
        String hundereds[] = {"","C","CC","CCC","CD","D","DC","DCC","DCCC","CM"};
        String thousands[]={"","M","MM","MMM"};
        
        return thousands[num/1000] + hundereds[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];
    }



13. roman to integer

class Solution {
    public int romanToInt(String s) {
        Map<Character, Integer> m = new HashMap<>();
        
        m.put('I', 1);
        m.put('V', 5);
        m.put('X', 10);
        m.put('L', 50);
        m.put('C', 100);
        m.put('D', 500);
        m.put('M', 1000);
        
        int ans = 0;
        
        for (int i = 0; i < s.length(); i++) {
            if (i < s.length() - 1 && m.get(s.charAt(i)) < m.get(s.charAt(i + 1))) {
                ans -= m.get(s.charAt(i));
            } else {
                ans += m.get(s.charAt(i));
            }
        }
        
        return ans;
    }
}

14. longest common p[refix

 public String longestCommonPrefix(String[] v) {
        StringBuilder ans = new StringBuilder();
        Arrays.sort(v);
        String first = v[0];
        String last = v[v.length-1];
        for (int i=0; i<Math.min(first.length(), last.length()); i++) {
            if (first.charAt(i) != last.charAt(i)) {
                return ans.toString();
            }
            ans.append(first.charAt(i));
        }
        return ans.toString();
    }